import { Injectable, Logger } from '@nestjs/common';
import { SecurityAnalyzer, SecurityAnalysisResult, SecurityVulnerability, SecuritySeverity } from './analyzers/security.analyzer';
import { TypeScriptAnalyzer } from './analyzers/typescript.analyzer';
import { JavaScriptAnalyzer } from './analyzers/javascript.analyzer';
import { ProjectAnalysis, FileAnalysis, SupportedLanguage } from '@codemapr/shared';
import * as fs from 'fs';
import * as path from 'path';

export interface SecurityScanResult {
  projectPath: string;
  totalFiles: number;
  scannedFiles: number;
  totalVulnerabilities: number;
  criticalCount: number;
  highCount: number;
  mediumCount: number;
  lowCount: number;
  riskScore: number;
  vulnerabilities: SecurityVulnerability[];
  fileResults: SecurityFileResult[];
  recommendations: SecurityRecommendation[];
  scanDuration: number;
}

export interface SecurityFileResult {
  filePath: string;
  vulnerabilities: SecurityVulnerability[];
  riskScore: number;
  summary: {
    criticalCount: number;
    highCount: number;
    mediumCount: number;
    lowCount: number;
  };
}

export interface SecurityRecommendation {
  id: string;
  title: string;
  description: string;
  priority: 'high' | 'medium' | 'low';
  category: string;
  affectedFiles: string[];
  actionItems: string[];
}

@Injectable()
export class SecurityVulnerabilityService {
  private readonly logger = new Logger(SecurityVulnerabilityService.name);

  constructor(
    private readonly securityAnalyzer: SecurityAnalyzer,
    private readonly typeScriptAnalyzer: TypeScriptAnalyzer,
    private readonly javaScriptAnalyzer: JavaScriptAnalyzer,
  ) {}

  async scanProject(projectPath: string): Promise<SecurityScanResult> {
    const startTime = Date.now();
    this.logger.log(`Starting security scan for project: ${projectPath}`);

    try {
      // Get all TypeScript and JavaScript files in the project
      const files = await this.getProjectFiles(projectPath);
      
      const fileResults: SecurityFileResult[] = [];
      const allVulnerabilities: SecurityVulnerability[] = [];
      let scannedFiles = 0;

      // Scan each file for security vulnerabilities
      for (const filePath of files) {
        try {
          this.logger.debug(`Processing file: ${filePath}`);
          const securityResult = await this.scanFileByPath(filePath);
          if (securityResult) {
            this.logger.debug(`Security scan completed for ${filePath}: ${securityResult.vulnerabilities.length} vulnerabilities`);
            fileResults.push(securityResult);
            allVulnerabilities.push(...securityResult.vulnerabilities);
            scannedFiles++;
          } else {
            this.logger.debug(`Skipped file (not supported or failed): ${filePath}`);
          }
        } catch (error) {
          this.logger.warn(`Failed to scan file ${filePath}: ${error.message}`);
        }
      }

      // Calculate overall statistics
      const criticalCount = allVulnerabilities.filter(v => v.severity === SecuritySeverity.CRITICAL).length;
      const highCount = allVulnerabilities.filter(v => v.severity === SecuritySeverity.HIGH).length;
      const mediumCount = allVulnerabilities.filter(v => v.severity === SecuritySeverity.MEDIUM).length;
      const lowCount = allVulnerabilities.filter(v => v.severity === SecuritySeverity.LOW).length;

      // Calculate project risk score (0-100)
      const riskScore = Math.min(100, 
        criticalCount * 25 + 
        highCount * 15 + 
        mediumCount * 8 + 
        lowCount * 3
      );

      // Generate recommendations
      const recommendations = this.generateRecommendations(allVulnerabilities, fileResults);

      const scanDuration = Date.now() - startTime;

      const result: SecurityScanResult = {
        projectPath,
        totalFiles: files.length,
        scannedFiles,
        totalVulnerabilities: allVulnerabilities.length,
        criticalCount,
        highCount,
        mediumCount,
        lowCount,
        riskScore,
        vulnerabilities: allVulnerabilities,
        fileResults,
        recommendations,
        scanDuration,
      };

      this.logger.log(`Security scan completed in ${scanDuration}ms. Found ${allVulnerabilities.length} vulnerabilities.`);
      return result;

    } catch (error) {
      this.logger.error(`Security scan failed for project ${projectPath}:`, error);
      throw error;
    }
  }

  async scanFileByPath(filePath: string): Promise<SecurityFileResult | null> {
    try {
      // Read file content
      const content = fs.readFileSync(filePath, 'utf-8');
      const language = this.detectLanguage(filePath);
      
      if (!language) {
        return null; // Skip unsupported files
      }

      // Analyze the file to get AST
      let fileAnalysis: FileAnalysis;
      
      if (language === SupportedLanguage.TYPESCRIPT || language === SupportedLanguage.TSX) {
        fileAnalysis = await this.typeScriptAnalyzer.analyzeFile(filePath, content);
      } else if (language === SupportedLanguage.JAVASCRIPT || language === SupportedLanguage.JSX) {
        fileAnalysis = await this.javaScriptAnalyzer.analyzeFile(filePath, content);
      } else {
        return null;
      }

      // Perform security analysis
      const securityResult = await this.scanFile(fileAnalysis);
      return securityResult;

    } catch (error) {
      this.logger.warn(`Failed to analyze file ${filePath}:`, error);
      return null;
    }
  }

  private async getProjectFiles(projectPath: string): Promise<string[]> {
    const files: string[] = [];
    const supportedExtensions = ['.ts', '.tsx', '.js', '.jsx', '.mjs', '.cjs'];
    const excludePatterns = ['node_modules', '.git', 'dist', 'build', '.next', 'coverage'];

    const walkDir = (dir: string) => {
      try {
        const items = fs.readdirSync(dir);
        
        for (const item of items) {
          const fullPath = path.join(dir, item);
          const stat = fs.statSync(fullPath);
          
          if (stat.isDirectory()) {
            // Skip excluded directories
            if (!excludePatterns.some(pattern => item.includes(pattern))) {
              walkDir(fullPath);
            }
          } else if (stat.isFile()) {
            // Include supported file types
            if (supportedExtensions.some(ext => item.endsWith(ext))) {
              files.push(fullPath);
            }
          }
        }
      } catch (error) {
        this.logger.warn(`Failed to read directory ${dir}:`, error.message);
      }
    };

    walkDir(projectPath);
    return files;
  }

  private detectLanguage(filePath: string): SupportedLanguage | null {
    const ext = path.extname(filePath).toLowerCase();
    
    switch (ext) {
      case '.ts':
        return SupportedLanguage.TYPESCRIPT;
      case '.tsx':
        return SupportedLanguage.TSX;
      case '.js':
      case '.mjs':
      case '.cjs':
        return SupportedLanguage.JAVASCRIPT;
      case '.jsx':
        return SupportedLanguage.JSX;
      default:
        return null;
    }
  }

  async scanFile(fileAnalysis: FileAnalysis): Promise<SecurityFileResult | null> {
    try {
      let securityResult: SecurityAnalysisResult;

      this.logger.debug(`Scanning file for security issues: ${fileAnalysis.filePath}, language: ${fileAnalysis.language}`);

      // Use appropriate analyzer based on file type
      if ((fileAnalysis.language === 'typescript' || fileAnalysis.language === 'tsx') && fileAnalysis.ast) {
        this.logger.debug(`Using TypeScript security analyzer for ${fileAnalysis.filePath}`);
        securityResult = await this.securityAnalyzer.analyzeTypeScriptFile(
          fileAnalysis.filePath,
          fileAnalysis.ast as any // TypeScript SourceFile
        );
      } else if ((fileAnalysis.language === 'javascript' || fileAnalysis.language === 'jsx') && fileAnalysis.ast) {
        this.logger.debug(`Using JavaScript security analyzer for ${fileAnalysis.filePath}`);
        securityResult = await this.securityAnalyzer.analyzeJavaScriptFile(
          fileAnalysis.filePath,
          fileAnalysis.ast as any // Babel AST
        );
      } else {
        this.logger.debug(`Skipping unsupported file type: ${fileAnalysis.filePath}, language: ${fileAnalysis.language}, ast: ${!!fileAnalysis.ast}`);
        // Skip unsupported file types
        return null;
      }

      this.logger.debug(`Security analysis completed for ${fileAnalysis.filePath}: ${securityResult.vulnerabilities.length} vulnerabilities found`);

      return {
        filePath: fileAnalysis.filePath,
        vulnerabilities: securityResult.vulnerabilities,
        riskScore: securityResult.riskScore,
        summary: {
          criticalCount: securityResult.summary.criticalCount,
          highCount: securityResult.summary.highCount,
          mediumCount: securityResult.summary.mediumCount,
          lowCount: securityResult.summary.lowCount,
        },
      };

    } catch (error) {
      this.logger.warn(`Failed to analyze security for file ${fileAnalysis.filePath}:`, error);
      return null;
    }
  }

  async getVulnerabilityDetails(vulnerabilityId: string, projectPath: string): Promise<SecurityVulnerability | null> {
    try {
      const scanResult = await this.scanProject(projectPath);
      return scanResult.vulnerabilities.find(v => v.id === vulnerabilityId) || null;
    } catch (error) {
      this.logger.error(`Failed to get vulnerability details for ${vulnerabilityId}:`, error);
      return null;
    }
  }

  async getSecurityMetrics(projectPath: string): Promise<{
    riskScore: number;
    vulnerabilityTrends: { date: string; count: number; severity: SecuritySeverity }[];
    topVulnerabilityTypes: { type: string; count: number }[];
    mostVulnerableFiles: { filePath: string; vulnerabilityCount: number; riskScore: number }[];
  }> {
    const scanResult = await this.scanProject(projectPath);

    // Calculate top vulnerability types
    const typeCount = new Map<string, number>();
    scanResult.vulnerabilities.forEach(vuln => {
      const count = typeCount.get(vuln.type) || 0;
      typeCount.set(vuln.type, count + 1);
    });

    const topVulnerabilityTypes = Array.from(typeCount.entries())
      .map(([type, count]) => ({ type, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);

    // Find most vulnerable files
    const mostVulnerableFiles = scanResult.fileResults
      .filter(file => file.vulnerabilities.length > 0)
      .map(file => ({
        filePath: file.filePath,
        vulnerabilityCount: file.vulnerabilities.length,
        riskScore: file.riskScore,
      }))
      .sort((a, b) => b.riskScore - a.riskScore)
      .slice(0, 10);

    // Mock vulnerability trends (in a real implementation, this would come from historical data)
    const vulnerabilityTrends = [
      { date: '2024-01-01', count: scanResult.criticalCount, severity: SecuritySeverity.CRITICAL },
      { date: '2024-01-01', count: scanResult.highCount, severity: SecuritySeverity.HIGH },
      { date: '2024-01-01', count: scanResult.mediumCount, severity: SecuritySeverity.MEDIUM },
      { date: '2024-01-01', count: scanResult.lowCount, severity: SecuritySeverity.LOW },
    ];

    return {
      riskScore: scanResult.riskScore,
      vulnerabilityTrends,
      topVulnerabilityTypes,
      mostVulnerableFiles,
    };
  }

  private generateRecommendations(
    vulnerabilities: SecurityVulnerability[],
    fileResults: SecurityFileResult[]
  ): SecurityRecommendation[] {
    const recommendations: SecurityRecommendation[] = [];

    // Group vulnerabilities by type
    const vulnsByType = new Map<string, SecurityVulnerability[]>();
    vulnerabilities.forEach(vuln => {
      const existing = vulnsByType.get(vuln.type) || [];
      existing.push(vuln);
      vulnsByType.set(vuln.type, existing);
    });

    // Generate recommendations for each vulnerability type
    vulnsByType.forEach((vulns, type) => {
      const affectedFiles = [...new Set(vulns.map(v => v.location.filePath))];
      const criticalCount = vulns.filter(v => v.severity === SecuritySeverity.CRITICAL).length;
      const highCount = vulns.filter(v => v.severity === SecuritySeverity.HIGH).length;

      let priority: 'high' | 'medium' | 'low' = 'low';
      if (criticalCount > 0) priority = 'high';
      else if (highCount > 0) priority = 'medium';

      const recommendation = this.createRecommendationForType(type, vulns, affectedFiles, priority);
      if (recommendation) {
        recommendations.push(recommendation);
      }
    });

    // Add general security recommendations
    if (vulnerabilities.length > 10) {
      recommendations.push({
        id: 'general-security-review',
        title: 'Comprehensive Security Review Needed',
        description: `Your project has ${vulnerabilities.length} security vulnerabilities. Consider conducting a comprehensive security review.`,
        priority: 'high',
        category: 'General',
        affectedFiles: fileResults.map(f => f.filePath),
        actionItems: [
          'Schedule a security code review with your team',
          'Implement automated security scanning in your CI/CD pipeline',
          'Consider using security linting tools like ESLint security plugins',
          'Review and update your security policies and guidelines',
        ],
      });
    }

    return recommendations.sort((a, b) => {
      const priorityOrder = { high: 3, medium: 2, low: 1 };
      return priorityOrder[b.priority] - priorityOrder[a.priority];
    });
  }

  private createRecommendationForType(
    type: string,
    vulnerabilities: SecurityVulnerability[],
    affectedFiles: string[],
    priority: 'high' | 'medium' | 'low'
  ): SecurityRecommendation | null {
    const count = vulnerabilities.length;
    const sample = vulnerabilities[0]; // Use first vulnerability as sample

    switch (type) {
      case 'sql_injection':
        return {
          id: `sql-injection-fix`,
          title: `Fix ${count} SQL Injection Vulnerabilities`,
          description: `Found ${count} potential SQL injection vulnerabilities. Use parameterized queries to prevent SQL injection attacks.`,
          priority,
          category: 'Injection',
          affectedFiles,
          actionItems: [
            'Replace string concatenation with parameterized queries',
            'Use ORM query builders instead of raw SQL',
            'Implement input validation and sanitization',
            'Review all database query construction code',
          ],
        };

      case 'xss':
        return {
          id: `xss-fix`,
          title: `Fix ${count} Cross-Site Scripting (XSS) Vulnerabilities`,
          description: `Found ${count} potential XSS vulnerabilities. Sanitize user input and avoid direct DOM manipulation.`,
          priority,
          category: 'Injection',
          affectedFiles,
          actionItems: [
            'Use textContent instead of innerHTML for user data',
            'Implement proper HTML sanitization',
            'Use Content Security Policy (CSP) headers',
            'Validate and escape all user inputs',
          ],
        };

      case 'command_injection':
        return {
          id: `command-injection-fix`,
          title: `Fix ${count} Command Injection Vulnerabilities`,
          description: `Found ${count} potential command injection vulnerabilities. Validate and sanitize all system command inputs.`,
          priority,
          category: 'Injection',
          affectedFiles,
          actionItems: [
            'Use allowlists for command parameters',
            'Implement strict input validation',
            'Use safer alternatives to system command execution',
            'Run commands with minimal privileges',
          ],
        };

      case 'hardcoded_secrets':
        return {
          id: `hardcoded-secrets-fix`,
          title: `Remove ${count} Hardcoded Secrets`,
          description: `Found ${count} hardcoded secrets in source code. Move secrets to environment variables or secure storage.`,
          priority,
          category: 'Secrets Management',
          affectedFiles,
          actionItems: [
            'Move secrets to environment variables',
            'Use secure secret management systems',
            'Add secrets to .gitignore patterns',
            'Rotate any exposed secrets immediately',
          ],
        };

      case 'insecure_crypto':
        return {
          id: `insecure-crypto-fix`,
          title: `Upgrade ${count} Weak Cryptographic Algorithms`,
          description: `Found ${count} uses of weak cryptographic algorithms. Upgrade to stronger alternatives.`,
          priority,
          category: 'Cryptography',
          affectedFiles,
          actionItems: [
            'Replace MD5 and SHA1 with SHA-256 or SHA-3',
            'Use cryptographically secure random number generators',
            'Implement proper key management',
            'Review all cryptographic implementations',
          ],
        };

      case 'unsafe_eval':
        return {
          id: `unsafe-eval-fix`,
          title: `Remove ${count} Unsafe Code Execution Patterns`,
          description: `Found ${count} uses of unsafe code execution functions. Replace with safer alternatives.`,
          priority,
          category: 'Code Injection',
          affectedFiles,
          actionItems: [
            'Remove eval() and Function() constructor usage',
            'Use JSON.parse() instead of eval() for data parsing',
            'Implement proper code validation if dynamic execution is needed',
            'Use safer alternatives like template engines',
          ],
        };

      default:
        return {
          id: `${type}-fix`,
          title: `Address ${count} ${type.replace('_', ' ')} Issues`,
          description: `Found ${count} ${type.replace('_', ' ')} vulnerabilities that need attention.`,
          priority,
          category: 'Security',
          affectedFiles,
          actionItems: [
            sample.recommendation,
            'Review affected code sections',
            'Implement proper security controls',
            'Test fixes thoroughly',
          ],
        };
    }
  }
}