import { Controller, Get, Post, Body, Param, Query, Logger, HttpException, HttpStatus } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiParam, ApiQuery, ApiBody } from '@nestjs/swagger';
import { IsString } from 'class-validator';
import { SecurityVulnerabilityService, SecurityScanResult, SecurityFileResult, SecurityRecommendation } from './security-vulnerability.service';
import { SecurityVulnerability } from './analyzers/security.analyzer';

export class SecurityScanRequestDto {
  @IsString()
  projectPath: string;
}

export class SecurityFileRequestDto {
  @IsString()
  filePath: string;
}

@ApiTags('Security Vulnerability Analysis')
@Controller('api/security')
export class SecurityVulnerabilityController {
  private readonly logger = new Logger(SecurityVulnerabilityController.name);

  constructor(private readonly securityService: SecurityVulnerabilityService) {}

  @Post('scan')
  @ApiOperation({ 
    summary: 'Scan project for security vulnerabilities',
    description: 'Performs a comprehensive security scan of the entire project and returns detailed vulnerability analysis.'
  })
  @ApiBody({ 
    type: SecurityScanRequestDto,
    description: 'Project path to scan for security vulnerabilities'
  })
  @ApiResponse({ 
    status: 200, 
    description: 'Security scan completed successfully',
    schema: {
      type: 'object',
      properties: {
        projectPath: { type: 'string' },
        totalFiles: { type: 'number' },
        scannedFiles: { type: 'number' },
        totalVulnerabilities: { type: 'number' },
        criticalCount: { type: 'number' },
        highCount: { type: 'number' },
        mediumCount: { type: 'number' },
        lowCount: { type: 'number' },
        riskScore: { type: 'number' },
        scanDuration: { type: 'number' },
        vulnerabilities: { type: 'array' },
        fileResults: { type: 'array' },
        recommendations: { type: 'array' }
      }
    }
  })
  @ApiResponse({ 
    status: 400, 
    description: 'Invalid project path or scan parameters' 
  })
  @ApiResponse({ 
    status: 500, 
    description: 'Internal server error during security scan' 
  })
  async scanProject(@Body() request: SecurityScanRequestDto): Promise<SecurityScanResult> {
    this.logger.log(`Security scan requested for project: ${request.projectPath}`);

    try {
      if (!request.projectPath) {
        throw new HttpException('Project path is required', HttpStatus.BAD_REQUEST);
      }

      const result = await this.securityService.scanProject(request.projectPath);
      
      this.logger.log(`Security scan completed for ${request.projectPath}: ${result.totalVulnerabilities} vulnerabilities found`);
      return result;

    } catch (error) {
      this.logger.error(`Security scan failed for project ${request.projectPath}:`, error);
      
      if (error instanceof HttpException) {
        throw error;
      }
      
      throw new HttpException(
        `Security scan failed: ${error.message}`,
        HttpStatus.INTERNAL_SERVER_ERROR
      );
    }
  }

  @Post('scan-file')
  @ApiOperation({ 
    summary: 'Scan single file for security vulnerabilities',
    description: 'Performs security analysis on a single file and returns vulnerability details.'
  })
  @ApiBody({ 
    type: SecurityFileRequestDto,
    description: 'File path to scan for security vulnerabilities'
  })
  @ApiResponse({ 
    status: 200, 
    description: 'File security scan completed successfully',
    schema: {
      type: 'object',
      properties: {
        filePath: { type: 'string' },
        vulnerabilities: { type: 'array' },
        riskScore: { type: 'number' },
        summary: {
          type: 'object',
          properties: {
            criticalCount: { type: 'number' },
            highCount: { type: 'number' },
            mediumCount: { type: 'number' },
            lowCount: { type: 'number' }
          }
        }
      }
    }
  })
  @ApiResponse({ 
    status: 400, 
    description: 'Invalid file path' 
  })
  @ApiResponse({ 
    status: 404, 
    description: 'File not found or not supported' 
  })
  async scanFile(@Body() request: SecurityFileRequestDto): Promise<SecurityFileResult | null> {
    this.logger.log(`File security scan requested: ${request.filePath}`);

    try {
      if (!request.filePath) {
        throw new HttpException('File path is required', HttpStatus.BAD_REQUEST);
      }

      // First get the file analysis
      const result = await this.securityService.scanFileByPath(request.filePath);
      
      if (!result) {
        throw new HttpException('File not found or not supported', HttpStatus.NOT_FOUND);
      }
      
      this.logger.log(`File security scan completed for ${request.filePath}: ${result?.vulnerabilities.length || 0} vulnerabilities found`);
      return result;

    } catch (error) {
      this.logger.error(`File security scan failed for ${request.filePath}:`, error);
      
      if (error instanceof HttpException) {
        throw error;
      }
      
      throw new HttpException(
        `File security scan failed: ${error.message}`,
        HttpStatus.INTERNAL_SERVER_ERROR
      );
    }
  }

  @Get('vulnerability/:id')
  @ApiOperation({ 
    summary: 'Get vulnerability details',
    description: 'Retrieves detailed information about a specific security vulnerability.'
  })
  @ApiParam({ 
    name: 'id', 
    description: 'Vulnerability ID',
    type: 'string'
  })
  @ApiQuery({ 
    name: 'projectPath', 
    description: 'Project path containing the vulnerability',
    type: 'string'
  })
  @ApiResponse({ 
    status: 200, 
    description: 'Vulnerability details retrieved successfully',
    schema: {
      type: 'object',
      properties: {
        id: { type: 'string' },
        type: { type: 'string' },
        severity: { type: 'string' },
        title: { type: 'string' },
        description: { type: 'string' },
        location: { type: 'object' },
        recommendation: { type: 'string' },
        cweId: { type: 'string' },
        owaspCategory: { type: 'string' },
        confidence: { type: 'number' },
        metadata: { type: 'object' }
      }
    }
  })
  @ApiResponse({ 
    status: 404, 
    description: 'Vulnerability not found' 
  })
  async getVulnerabilityDetails(
    @Param('id') vulnerabilityId: string,
    @Query('projectPath') projectPath: string
  ): Promise<SecurityVulnerability> {
    this.logger.log(`Vulnerability details requested: ${vulnerabilityId}`);

    try {
      if (!projectPath) {
        throw new HttpException('Project path is required', HttpStatus.BAD_REQUEST);
      }

      const vulnerability = await this.securityService.getVulnerabilityDetails(vulnerabilityId, projectPath);
      
      if (!vulnerability) {
        throw new HttpException('Vulnerability not found', HttpStatus.NOT_FOUND);
      }

      return vulnerability;

    } catch (error) {
      this.logger.error(`Failed to get vulnerability details for ${vulnerabilityId}:`, error);
      
      if (error instanceof HttpException) {
        throw error;
      }
      
      throw new HttpException(
        `Failed to get vulnerability details: ${error.message}`,
        HttpStatus.INTERNAL_SERVER_ERROR
      );
    }
  }

  @Get('metrics')
  @ApiOperation({ 
    summary: 'Get security metrics',
    description: 'Retrieves comprehensive security metrics and trends for the project.'
  })
  @ApiQuery({ 
    name: 'projectPath', 
    description: 'Project path to analyze',
    type: 'string'
  })
  @ApiResponse({ 
    status: 200, 
    description: 'Security metrics retrieved successfully',
    schema: {
      type: 'object',
      properties: {
        riskScore: { type: 'number' },
        vulnerabilityTrends: { type: 'array' },
        topVulnerabilityTypes: { type: 'array' },
        mostVulnerableFiles: { type: 'array' }
      }
    }
  })
  @ApiResponse({ 
    status: 400, 
    description: 'Invalid project path' 
  })
  async getSecurityMetrics(@Query('projectPath') projectPath: string) {
    this.logger.log(`Security metrics requested for project: ${projectPath}`);

    try {
      if (!projectPath) {
        throw new HttpException('Project path is required', HttpStatus.BAD_REQUEST);
      }

      const metrics = await this.securityService.getSecurityMetrics(projectPath);
      
      this.logger.log(`Security metrics retrieved for ${projectPath}: Risk score ${metrics.riskScore}`);
      return metrics;

    } catch (error) {
      this.logger.error(`Failed to get security metrics for ${projectPath}:`, error);
      
      if (error instanceof HttpException) {
        throw error;
      }
      
      throw new HttpException(
        `Failed to get security metrics: ${error.message}`,
        HttpStatus.INTERNAL_SERVER_ERROR
      );
    }
  }

  @Get('recommendations')
  @ApiOperation({ 
    summary: 'Get security recommendations',
    description: 'Retrieves actionable security recommendations based on vulnerability analysis.'
  })
  @ApiQuery({ 
    name: 'projectPath', 
    description: 'Project path to analyze',
    type: 'string'
  })
  @ApiResponse({ 
    status: 200, 
    description: 'Security recommendations retrieved successfully',
    schema: {
      type: 'array',
      items: {
        type: 'object',
        properties: {
          id: { type: 'string' },
          title: { type: 'string' },
          description: { type: 'string' },
          priority: { type: 'string' },
          category: { type: 'string' },
          affectedFiles: { type: 'array' },
          actionItems: { type: 'array' }
        }
      }
    }
  })
  @ApiResponse({ 
    status: 400, 
    description: 'Invalid project path' 
  })
  async getSecurityRecommendations(@Query('projectPath') projectPath: string): Promise<SecurityRecommendation[]> {
    this.logger.log(`Security recommendations requested for project: ${projectPath}`);

    try {
      if (!projectPath) {
        throw new HttpException('Project path is required', HttpStatus.BAD_REQUEST);
      }

      const scanResult = await this.securityService.scanProject(projectPath);
      
      this.logger.log(`Security recommendations retrieved for ${projectPath}: ${scanResult.recommendations.length} recommendations`);
      return scanResult.recommendations;

    } catch (error) {
      this.logger.error(`Failed to get security recommendations for ${projectPath}:`, error);
      
      if (error instanceof HttpException) {
        throw error;
      }
      
      throw new HttpException(
        `Failed to get security recommendations: ${error.message}`,
        HttpStatus.INTERNAL_SERVER_ERROR
      );
    }
  }

  @Get('health')
  @ApiOperation({ 
    summary: 'Security service health check',
    description: 'Checks if the security vulnerability service is operational.'
  })
  @ApiResponse({ 
    status: 200, 
    description: 'Security service is healthy',
    schema: {
      type: 'object',
      properties: {
        status: { type: 'string' },
        timestamp: { type: 'string' },
        service: { type: 'string' }
      }
    }
  })
  async healthCheck() {
    return {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      service: 'SecurityVulnerabilityService',
    };
  }
}